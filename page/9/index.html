<!doctype html><!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang=en><![endif]--><!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang=en><![endif]--><!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang=en><![endif]--><!--[if gt IE 8]><!--><html class=no-js lang=en><!--<![endif]--><head><meta charset=utf-8><title>Le murmure de Julian</title><meta name=description content><meta property="og:title" content="Le murmure de Julian"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://blog.jln.co/"><meta property="og:image" content="http://blog.jln.co/images/avatar.png"><meta property="og:updated_time" content="2017-06-18T12:21:33+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://blog.jln.co/images/avatar.png"><meta name=twitter:title content="Le murmure de Julian"><meta name=twitter:description content><link rel=canonical href=http://blog.jln.co/><link href=http://blog.jln.co/feed.xml rel=alternate type=application/rss+xml title="Le murmure de Julian"><link href=http://blog.jln.co/feed.xml rel=feed type=application/rss+xml title="Le murmure de Julian"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/main.css><link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel=stylesheet type=text/css><meta http-equiv=cleartype content="on"><meta name=generator content="Hugo 0.73.0"><script src=/js/vendor/modernizr-2.6.2.custom.min.js></script><script async src=https://unpkg.com/mermaid@8.2.3/dist/mermaid.min.js></script><link rel="shortcut icon" href=/favicon.png></head><body id=post-index class=feature><nav id=dl-menu class=dl-menuwrapper role=navigation style=display:inline-block><button class=dl-trigger>Open Menu</button><ul class=dl-menu><li><a href=/>Home</a></li><li><a href=#>About</a><ul class=dl-submenu><li><img src=/images/avatar.png alt="Julian Shen's photo" class=author-photo><h4>Julian Shen</h4><p>Softward developer</p></li><li><a href=mailto:julianshen22@gmail.com><i class="fa fa-fw fa-envelope"></i>Email</a></li><li><a href=https://linkedin.com/in/julianshen><i class="fa fa-fw fa-linkedin"></i>LinkedIn</a></li><li><a href=https://github.com/julianshen><i class="fa fa-fw fa-github"></i>GitHub</a></li><li><a href=https://instagram.com/julianshen><i class="fa fa-fw fa-instagram"></i>Instagram</a></li></ul></li><li><a href=#>Posts</a><ul class=dl-submenu><li><a href=/post/>All Posts</a></li><li><a href=/tags/>All Tags</a></li></ul></li><li><a href=/></a></li></ul></nav><div class=entry-header><div class=entry-image><img src=/images/bkg2.jpg alt="Le murmure de Julian"></div><div class=header-title><div class=header-title-wrap><h1><a href=/ title="Go to the homepage">Le murmure de Julian</a></h1><h2>朱隸安貓囈語錄</h2></div></div></div><div id=main role=main><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2016-06-16 20:37:58 +0000 UTC"><a href=/%E5%8F%88%E5%86%8D%E6%8A%8ABlog%E6%90%AC%E5%AE%B6%E4%BA%86/>Jun 16, 2016</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>Reading time ~7 minutes</span></div><h1 class=entry-title><a href=/%E5%8F%88%E5%86%8D%E6%8A%8ABlog%E6%90%AC%E5%AE%B6%E4%BA%86/ rel=bookmark title=又再把Blog搬家了 itemprop=url>又再把Blog搬家了</a></h1></header><div class=entry-content><p>一直把Blog當作紀錄一些事情用的地方, 想法, 或是學習過的一些東西, 雖然不是很頻繁的在寫, 不過也寫了好幾年了, 從以前到現在, 換過好幾次平台, 從自己架的wordpress, 到posterous, blogger, 一直到現在用的Tumblr, 這中間最喜歡的還是posterous, 不過它已經不存在了, 而Tumblr也用了好一陣子了, 雖然加減湊合著用好像還OK, 不過編輯上也一直不是那麼順手, 尤其是貼source code, 因此也一直想把它換掉</p><p>那 <strong>medium</strong> 呢? medium我還沒很有動力去搞懂它, 會在上面看一些文章沒錯, 但把Blog移到上面去, 好像也沒啥動力</p><p>考慮了好一陣子, 不過最後還是把整個Blog遷移了, 反正現在有一個自己的domain (<em>blog.jln.co</em>), 搬家不用改地址!</p><p>遷移之前, 想了幾個我的需求:</p><h4 id=需求>需求</h4><ol><li>有方便的編輯器可以用, 最好可以支援mark down, 打html有點麻煩, WYSIWYG編輯器通常效率也不高</li><li>貼code好貼, 也方便閱讀</li><li>模版好編輯, 至少我要能知道怎麼改模版</li><li>好預覽</li><li>能同步到各個social network, 至少Facebook, Twitter, 也能同步到我原本的Tumblr和blogger</li><li>要能夠友善支援Open graph和Twitter card, 對每次share的FB的醜醜文字版型實在不喜歡</li><li>好轉移, 好備份, 有版本控制更好!</li></ol><h4 id=解決方案>解決方案</h4><p>現成的blog service, 好的什麼都要錢(ghost, wordpress), 免費的大概也都被我用過了, 自己架, 又得管server, 後來想想, blog都是靜態的網頁, 也真的不需要一個很複雜的系統, 這時候就想到一個解決方案, 那就是Github</p><p>Github有一個<a href=https://pages.github.com>Github pages</a>的服務, 可以讓你host你的靜態網頁, 所以只要有一個方法可以把Blog轉成靜態網頁就可以了, 這個還蠻Geek的方式感覺就蠻適合我的</p><p>找到了幾個方法轉blog:</p><ol><li><a href=https://jekyllrb.com>Jekyll</a></li><li><a href=http://octopress.org>Octopress</a></li><li><a href=https://hexo.io/zh-tw/>Hexo</a></li></ol><p>Octopress是已經完結不再維護了, 所以就Jekyll和Hexo兩個在抉擇, 兩者都有蠻多的主題跟模版功能, 也有不少plugins</p><p>Hexo是台灣精品, 而且是nodekjs寫的, 語言上我比較熟, 要改比較好改,而Jekyll是Ruby寫的, 我跟Ruby很不熟, 但它跟Github pages結合緊密, 而且已經有tool可以從Tumblr移轉內容過來了, 最後我選擇了Jekyll, 選擇Jekyll的原因是</p><ol><li>Github page直接原生支援, 只要把md檔push上去後, 就會自動產生網頁(不過後來我還是先在自己電腦產生完再push, 後面再說原因)</li><li>找到一個適合的也不太難改的theme, 就懶得去翻Hexo的了, 而且找到的那個對Open graph和Twitter card的支援也不錯, 不用改太多</li><li>原生的Tumblr import tool</li></ol><p>不過整個也花了不少個晚上修改, 又花了一個晚上才能寫完這篇紀錄 @@</p><h4 id=安裝jekyll>安裝Jekyll</h4><p>網路上可以找到很多安裝Jekyll的文章, 這邊就不說太多, 我試了兩個不同的作法:</p><h5 id=作法-1>作法 1</h5><p>這是最基本的作法</p><ol><li>先用 <code>gem install jekyll</code> 安裝jekyll</li><li>用 <code>jekyll new myblog</code> 在myblog目錄產生一個基本的網站</li><li>用 <code>jekyll s</code> 會在 localhost:4000 開啟一個服務, 這時就透過browser可以看看你的blog長怎樣了</li></ol><p>這方法的缺點是, 套用主題時, 還得改一堆東西, 有點麻煩</p><h5 id=作法-2>作法 2</h5><ol><li>一樣先裝jekyll</li><li>找到一個人家做好的theme (我是用<a href=https://github.com/mmistakes/hpstr-jekyll-theme>hpstr</a>這個), clone下來改, 因為大部分的都已經把他用的plugin之類的都先寫好在config了, 就省不少事, 建議找theme要注意其對應的Jekyll版本, 像我裝的Jekyll是3, 所以找的是適合3的</li><li>用 <code>gem install bundler</code> 安裝bundler</li><li>用 <code>bundle install</code> 來安裝相關的plugins</li><li>用 <code>jekyll s</code> 看結果</li></ol><p>我後來採用的是作法2, 踩在人家的肩膀上比較快 :P</p><h4 id=設定github-pages>設定github pages</h4><p>這部份沒什麼難度, 創建一個專案名稱叫做 <em>你的名字.github.com</em> , 把相關檔案放到這邊去就行了</p><p>Github pages支援兩種方式, 一種是純粹的靜態網頁, 就是把html跟其他相關檔案丟到這邊就好(master branch), 另一種方式就是Jekyll, Jekyll的部分只要把前一個動作的檔案放進來就好, 它會自己幫你產生對應的靜態網頁</p><p>不過第二種方法的缺點是因為Github pages只支援幾種Jekyll plugins, 而且不支援自訂的plugins(放在 <em>_plugins</em> 目錄下的), 就算你在你自己電腦裡面跑完把產生後的 <strong>_site</strong> 目錄一起放上去也是沒用的</p><h4 id=從tumblr匯入之前文章>從Tumblr匯入之前文章</h4><p>這部份沒太複雜, 是透過<a href=https://github.com/jekyll/jekyll-import>jekyll-import</a></p><p>安裝jekyll-import一樣可以透過<code>gem install</code>來安裝, 但建議不要這樣做, 是因為他用的Tumblr API是JSONP但程式卻將它當一般JSON在解碼, 會出錯, 這部份在最新版的code有解決(害我還去追了source code), 所以抓source回來自己build比較安全</p><p>裝好之後執行:</p><pre><code>#!/bin/sh
ruby -rubygems -e 'require &quot;jekyll-import&quot;;
    JekyllImport::Importers::Tumblr.run({
      &quot;url&quot;            =&gt; &quot;http://blog.jln.co&quot;,
      &quot;format&quot;         =&gt; &quot;html&quot;, # or &quot;md&quot;
      &quot;grab_images&quot;    =&gt; true,  # whether to download images as well.
      &quot;add_highlights&quot; =&gt; false,  # whether to wrap code blocks (indented 4 spaces) in a Liquid &quot;highlight&quot; tag
      &quot;rewrite_urls&quot;   =&gt; false   # whether to write pages that redirect from the old Tumblr paths to the new Jekyll paths
    })'
</code></pre><p>它就會把文章抓回到 <em>_post</em>的目錄下</p><h4 id=open-graph--twitter-card>Open graph & Twitter card</h4><p>如果把內容分享到Facebook或是Twitter上只有短短的文字, 不是很好看, 所以希望在這部份能夠至少加上一張圖</p><p><a href=https://github.com/mmistakes/hpstr-jekyll-theme>hpstr</a>這個theme已經有在 ** _includes/head.html ** 寫好OG跟Twitter card相關的tag了, 圖片(og:image)的部分, 他的規則/順序是:</p><ol><li>Front matter 裡面設定的</li><li>_config.xml 裡的logo設定</li></ol><p>我希望是更自動一點, 而不是自己去設定, 所以找到一個plugin : <a href=https://github.com/merlos/jekyll-auto-image>jekyll-auto-image</a>, 這個plugin聰明一點, 他的順序是:</p><ol><li>內文內出現的第一張圖</li><li>_config.xml 裡面設定的圖</li></ol><p>但這樣還稍嫌單調一些, 我想要達成的是:</p><ol><li>內文內出現的第一張圖</li><li>根據標籤選的對應的圖(比如說把我go語言相關的設成Gopher的圖片), 這樣不會每個都一樣, 比較有變化一點</li><li>預設的圖</li></ol><p>再加上auto image裡面關於image的設定跟我用的theme有所衝突, 這就需要把原本的auto image改一下了</p><p>我新增一個rb檔, 放在 ** _plugins **目錄下, 內容如下:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>require <span style=color:#e6db74>&#34;jekyll&#34;</span>

<span style=color:#66d9ef>module</span> Jekyll

  <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AutoImageGenerator</span> <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>Generator</span>

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>generate</span>(site)
      @site <span style=color:#f92672>=</span> site

      site<span style=color:#f92672>.</span>pages<span style=color:#f92672>.</span>each <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>page<span style=color:#f92672>|</span>
        img <span style=color:#f92672>=</span> get_image(page)
        page<span style=color:#f92672>.</span>data<span style=color:#f92672>[</span><span style=color:#e6db74>&#39;image1&#39;</span><span style=color:#f92672>]</span> <span style=color:#f92672>=</span> img <span style=color:#66d9ef>if</span> img
      <span style=color:#66d9ef>end</span>
      <span style=color:#75715e># Now do the same with posts</span>
      site<span style=color:#f92672>.</span>posts<span style=color:#f92672>.</span>docs<span style=color:#f92672>.</span>each <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>post<span style=color:#f92672>|</span>
        <span style=color:#75715e>#puts &#34;hola&#34;</span>
        <span style=color:#75715e>#puts Jekyll::VERSION</span>
        <span style=color:#75715e>#puts post.class</span>
        <span style=color:#75715e>#puts post.inspect</span>
        <span style=color:#75715e>#puts post.data.inspect</span>
        <span style=color:#75715e>#puts &#34;-----&#34;      </span>
        <span style=color:#75715e>#puts post.output</span>
        <span style=color:#75715e>#puts &#34;----&#34;</span>
        img <span style=color:#f92672>=</span> get_image(post)
        post<span style=color:#f92672>.</span>data<span style=color:#f92672>[</span><span style=color:#e6db74>&#39;thumb&#39;</span><span style=color:#f92672>]</span> <span style=color:#f92672>=</span> img <span style=color:#66d9ef>if</span> img
      <span style=color:#66d9ef>end</span>
    <span style=color:#66d9ef>end</span> <span style=color:#75715e># generate</span>

    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_image</span>(page)

      <span style=color:#66d9ef>if</span> page<span style=color:#f92672>.</span>data<span style=color:#f92672>[</span><span style=color:#e6db74>&#39;thumb&#39;</span><span style=color:#f92672>]</span>
        <span style=color:#66d9ef>return</span> page<span style=color:#f92672>.</span>data<span style=color:#f92672>[</span><span style=color:#e6db74>&#39;thumb&#39;</span><span style=color:#f92672>]</span>
      <span style=color:#66d9ef>end</span>
      <span style=color:#75715e># convert the contents to html, and extract the first &lt;img src=&#34;&#34; apearance</span>
      <span style=color:#75715e># I know, it&#39;s not efficient, but rather easy to implement :)</span>

      <span style=color:#66d9ef>if</span> page<span style=color:#f92672>.</span>class <span style=color:#f92672>==</span> <span style=color:#66d9ef>Jekyll</span><span style=color:#f92672>::</span><span style=color:#66d9ef>Document</span> <span style=color:#75715e># for jekyll 3.0 posts &amp; collections</span>
        htmled <span style=color:#f92672>=</span> <span style=color:#66d9ef>Jekyll</span><span style=color:#f92672>::</span><span style=color:#66d9ef>Renderer</span><span style=color:#f92672>.</span>new(@site, page, @site<span style=color:#f92672>.</span>site_payload)<span style=color:#f92672>.</span>convert(page<span style=color:#f92672>.</span>content)
      <span style=color:#66d9ef>else</span>
        htmled <span style=color:#f92672>=</span> page<span style=color:#f92672>.</span>transform <span style=color:#75715e># for jekyll 2.x pages</span>
      <span style=color:#66d9ef>end</span>

      img_url <span style=color:#f92672>=</span> htmled<span style=color:#f92672>.</span>match(<span style=color:#e6db74>/&lt;img.*\ssrc=[\&#34;\&#39;]([\S.]+)[\&#34;\&#39;]/i</span>)
      <span style=color:#66d9ef>return</span> img_url<span style=color:#f92672>[</span><span style=color:#ae81ff>1</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>if</span> img_url <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>

      tags <span style=color:#f92672>=</span> page<span style=color:#f92672>.</span>data<span style=color:#f92672>[</span><span style=color:#e6db74>&#39;tags&#39;</span><span style=color:#f92672>]</span>
      imagemap <span style=color:#f92672>=</span> @site<span style=color:#f92672>.</span>config<span style=color:#f92672>[</span><span style=color:#e6db74>&#39;imagemap&#39;</span><span style=color:#f92672>]</span>
      <span style=color:#66d9ef>if</span> tags <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> imagemap <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>
        tags<span style=color:#f92672>.</span>each <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>t<span style=color:#f92672>|</span>
          <span style=color:#66d9ef>if</span> imagemap<span style=color:#f92672>[</span>t<span style=color:#f92672>.</span>downcase<span style=color:#f92672>]</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>
            url <span style=color:#f92672>=</span> imagemap<span style=color:#f92672>[</span>t<span style=color:#f92672>.</span>downcase<span style=color:#f92672>]</span>

            <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>url<span style=color:#f92672>.</span>match(<span style=color:#e6db74>/^http/</span>)
              url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;/images/&#39;</span> <span style=color:#f92672>+</span> url
            <span style=color:#66d9ef>end</span>
            <span style=color:#66d9ef>return</span> url
          <span style=color:#66d9ef>end</span>
        <span style=color:#66d9ef>end</span>
      <span style=color:#66d9ef>end</span>

      <span style=color:#66d9ef>return</span> @site<span style=color:#f92672>.</span>config<span style=color:#f92672>[</span><span style=color:#e6db74>&#39;logo&#39;</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>if</span> @site<span style=color:#f92672>.</span>config<span style=color:#f92672>[</span><span style=color:#e6db74>&#39;logo&#39;</span><span style=color:#f92672>]</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>
      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
    <span style=color:#66d9ef>end</span>

  <span style=color:#66d9ef>end</span> <span style=color:#75715e># class</span>
<span style=color:#66d9ef>end</span> <span style=color:#75715e># module</span>
</code></pre></div><p>這版就有達到我想要的目的, 但這不代表問題解了, 反而是問題的開始, 前面有說過github只支援特定的plugins, 所以怎樣這段改過的plugin都不會被它執行到, 唯一能做的解法就是改用靜態網頁的方式</p><p>jekyll產生的靜態網頁都放在 _site 目錄下, 所以真的要進master branch只有這裡面的, 其他都不用, 所以要先在本地端用 <code>jekyll b</code>去產生相關的靜態網頁到 _site裡再上傳</p><p>那怎測試呢? 一開始為了測試方便我都以本地端的server做測試, 但如果要測試Facebook share的話則需要能夠讓Facebook 連過來抓取網頁來分析, 但這點在區網不是很方便, 所以就帶入了 <a href=https://ngrok.com>ngrok</a> 這個工具, 這工具就是提供給你一個外部的網址, 你在本地端跑了ngrok這程式後, 就有一個可以對應你本地端的server, 還蠻好用的</p><h4 id=自動發布到社群網站>自動發布到社群網站</h4><p>這當然是用<a href=http://ifttt.com>ifttt</a>囉, 因為有用到jekyll-feed這個plugin, 所以會產生一個feed.xml的檔案, 所以就利用ifttt的feed channel來設定觸發</p><h4 id=結語>結語</h4><p>本來明明不想花太多功夫的, 結果不但花了很多功夫, 還花了一頁來紀錄這篇 orz</p></div></article><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2016-02-25 01:13:36 +0000 UTC"><a href=/%E7%AD%86%E8%A8%98-%E7%A7%BB%E6%A4%8DParse-Push/>Feb 25, 2016</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>Reading time ~3 minutes</span></div><h1 class=entry-title><a href=/%E7%AD%86%E8%A8%98-%E7%A7%BB%E6%A4%8DParse-Push/ rel=bookmark title="[筆記] 移植Parse Push" itemprop=url>[筆記] 移植Parse Push</a></h1></header><div class=entry-content><p>今天追完了綠箭, 該來點功課, 不過今天忘了買啤酒了:(</p><p>Parse Push, 這功能無疑應該是Parse本身比較受歡迎的部分, 既然Parse明年要關門大吉了,這部份也是必須要搬家的, 但搬家比較麻煩的不是要搬到哪去, 而是之前累積的使用者, 總不希望一搬了就找不到他們了, Parse Push支援了包含了Google的GCM和Apple的APNS,以及他們自己的PPNS,以GCM來說, 在_Installation裡面, Parse是有儲存了GCM的deviceToken, 如果你之前用的是自己的GCM Sender ID, 那這部份直接搬了就可以用了, 但如果不是, 那預設用的是Parse自己的, 這樣這些deviceToken就不能夠使用自己的Sender ID來送, 必須要用用下面的方法來補救:</p><ul><li>從Google的<a href=https://console.developers.google.com/>Developer console</a>取的Sender ID跟API Key</li><li>在AndroidManifest.xml加入 <code>&lt;meta-data android:name="com.parse.push.gcm_sender_id" android:value="id:12345678"></code> (必須要以"id:&ldquo;加上你的sender id)</li><li>發布新的升級到Play store</li><li>使用者更新後至少發送一次Push (如果你在Application中有去儲存Installation, 這時候因為有了新的sender, 所以deviceToken會被更新)</li><li>可以用你自己的API key送給新的device token了(可以不用透過Parse console去送, 也可以用其他程式)</li></ul><p>這個Go的範例可以用來試驗送PUSH到你的手機上:</p><script src=https://gist.github.com/julianshen/90a7b5c4a24eb13f41fa.js></script><p>找出你手機的deviceToken後即可用這個來驗證是否能夠成功送出push</p><p>但這樣還不夠, 我們還需要一個負責幫我們送push的server, 在之前那篇<a href=http://blog.jln.co/post/139174339467/%E7%AD%86%E8%A8%98-parse-%E8%87%AA%E6%95%91%E6%96%B9%E6%A1%88%E4%B9%8B%E4%B8%80-pushd>Parse自救方案</a>裡有提到一個Pushd, 這是其中一個作法, 不過需要改一些東西才可以符合Parse Android SDK接收的格式, 另一個作法是透過open source的<a href=https://github.com/ParsePlatform/parse-server/>Parse Server</a>, 原本它剛一出來時, 並沒支援Push, 但後來有其他人幫它加了上去了, 但它的方式是提供了API給你送PUSH, 但一來把API server跟PUSH server放一起並不是件好事, 二來當送大量的PUSH這樣的設計並不保險(並沒有queue, 送到一半server死了就麻煩了)</p><p>不過要以Parse server的為基礎拆出push的部分也不是很難, 做了一個簡單的範例: <a href=https://github.com/julianshen/parse_push_js>github.com/julianshen/parse_push_js</a></p><p>在這範例裡, 使用了Parse Server的ParsePushAdapter, 並且利用了Redis當作queue來做成的簡單的push server, 這樣應該就加減堪用了, 不過這邊有一個還需要再改的是, ParsePushAdapter 並不會把產生的push id回傳到上一層, 這樣要做追蹤紀錄其實有點比較不方便, 這邊還需要再加強一下</p></div></article><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2016-02-18 09:23:42 +0000 UTC"><a href=/%E7%AD%86%E8%A8%98-%E8%A2%AB%E5%86%A4%E6%9E%89%E7%9A%84MongoDB/>Feb 18, 2016</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>Reading time ~2 minutes</span></div><h1 class=entry-title><a href=/%E7%AD%86%E8%A8%98-%E8%A2%AB%E5%86%A4%E6%9E%89%E7%9A%84MongoDB/ rel=bookmark title="[筆記] 被冤枉的MongoDB" itemprop=url>[筆記] 被冤枉的MongoDB</a></h1></header><div class=entry-content><p>續<a href=http://blog.jln.co/post/139117302737/%E7%AD%86%E8%A8%98-deploy-mongodb-replica-set-to-coreosfleet>前篇</a> 裝好了MongoDB的Cluster後(1 Primary, 2 Secondaries)就開始進行大量的資料移轉</p><p>結果資料寫到一半, 突然發現Primary換人了, 雖然因為有Secondaries, 會有人上來替代, 因為Mongo只有Primary才可以被寫入, 這使得client必須重新建立對新的primary的connection, 一度以為機器被reboot了, 但查logs並沒這現象, 後來又以為, MongoDB也太不濟了吧, 這種量級的寫入居然可以擊倒它, 結果後來查了log發現, 他的確被restart了, 只是兇手不是他, 是別人叫他去死的</p><p>一切是Fleet惹的禍, 根據這篇<a href=https://github.com/coreos/fleet/issues/1289>Fleet engine stops units when etcd leadership change or has connectivity issues #1289</a>, Fleet只要聯絡不到etcd, 就會認為不能獨活了, 就會把其他人也給殺了(可惡的殺人兇手),追根據底就是timeout設的太短了, 以至於當系統稍微(只是稍微而已)一忙, 就很容易超過timeout, 然後他就認為, 他的情人死了!(也太玻璃心了)</p><p>解決方案就是延長timeout, 修改cloud-config加上如下的東西(把etcd的heartbeat跟election timeout延長, 把fleet相關的也給延長):</p><pre>

#cloud-config

coreos:
  etcd2:
    heartbeat-interval: 600
    election-timeout: 6000
  fleet:
    engine-reconcile-interval: 10
    etcd-request-timeout: 5
    agent-ttl: 120s

</pre><p>至於Azure上裝的coreos, cloud-config位置是在: <code>/var/lib/waagent/CustomData</code>, 改完restart機器就好</p></div></article><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2016-02-12 23:41:25 +0000 UTC"><a href=/%E7%AD%86%E8%A8%98-Parse-%E8%87%AA%E6%95%91%E6%96%B9%E6%A1%88%E4%B9%8B%E4%B8%80-Pushd/>Feb 12, 2016</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>Reading time ~2 minutes</span></div><h1 class=entry-title><a href=/%E7%AD%86%E8%A8%98-Parse-%E8%87%AA%E6%95%91%E6%96%B9%E6%A1%88%E4%B9%8B%E4%B8%80-Pushd/ rel=bookmark title="[筆記] Parse 自救方案之一 - Pushd" itemprop=url>[筆記] Parse 自救方案之一 - Pushd</a></h1></header><div class=entry-content><p>Parse自從宣布要收掉後, 雖然也放出open source的仿製品<a href=https://github.com/ParsePlatform/parse-server>Parse Server</a>, 這東西不是實際上Parse真正跑得那個app server, 而是一個nodejs/express的相容版, 這個版本的故事可以看這邊 <a href=https://medium.com/@newfosco/parse-2-0-600839abebdf#.vcv4l2lg2>Parse 2.0</a></p><p>想當然爾, 這版本並不是完整支援Parse原本的功能, 尤其是Push, 這功能是完全沒有, 雖然說source codes放出來後, 大家熱烈的玩起來了, 最近幾天一個簡單的PUSH功能的pull request也被收錄進去了: <a href=https://github.com/ParsePlatform/parse-server/pull/311>Add support for push</a>, 不過這畢竟比較陽春</p><p>一些收費不收費的替代方案也不算少, 不過如果想自救, 自己建置自己管的話, 也是不用完全重來, <a href=https://github.com/rs/pushd>rs/pushd</a> 這是目前看到還算蠻完整的, 採用了nodejs/coffee script + Redis, 在佈署方面也不算太難(不過也就兩個東西而已), 不過實際上的效能可能還是得測試一下(有沒好方法可以測大量的push呀?總不可能去生一堆機器)</p><p>為了方便測試, 包裝成docker-compose.yml和一個方便使用的shell script: <a href=https://github.com/julianshen/pushd-docker-compose-sample>julianshen/pushd-docker-compose-sample</a></p><p>使用方法:</p><ul><li>修改<code>pushd.sh</code>裡跟你的app相關的push設定如GCM_KEY</li><li>執行<code>pushd.sh up</code>啟動redis和pushd兩個containers</li><li>執行<code>pushd.sh ps</code>確認是不是兩個都已經正確啟動</li><li>PUSHD的port是對應到host的8081, 所以直接對8081操作即可</li></ul><p>接下來可能要想一些方法來測試, 和把Parse的資料給串一起</p></div></article><article class=hentry><header><div class=entry-meta><span class="entry-date date published updated"><time datetime="2016-02-12 00:34:07 +0000 UTC"><a href=/%E7%AD%86%E8%A8%98-Deploy-Mongodb-replica-set-to-coreos/fleet-cluster-on-Azure/>Feb 12, 2016</a></time></span>
<span class=entry-reading-time><i class="fa fa-clock-o"></i>Reading time ~5 minutes</span></div><h1 class=entry-title><a href=/%E7%AD%86%E8%A8%98-Deploy-Mongodb-replica-set-to-coreos/fleet-cluster-on-Azure/ rel=bookmark title="[筆記] Deploy Mongodb replica set to coreos/fleet cluster on Azure" itemprop=url>[筆記] Deploy Mongodb replica set to coreos/fleet cluster on Azure</a></h1></header><div class=entry-content><p>把我過年假期試的先來紀錄一下，這篇基本上有兩個部分:</p><p>第一部份是在Azure上部署一個coreos cluster，這部份可以參考以下幾篇：</p><ul><li><a href="https://m.youtube.com/watch?v=wxUxtflalE4">Scaling Docker #1 - High Availability Docker DevOps with CoreOS, Etcd, Fleet, Flannel & Nginx</a></li><li><a href=https://github.com/willrstern/production-docker-ha-architecture>willrstern/production-docker-ha-architecture</a> - 這是上一段影片用的source codes, 那段影片有好幾段, 講的蠻清楚的, 但是佈署在Digital Ocean上, 這邊我借用他的cloud-config</li><li><a href=https://azure.microsoft.com/zh-tw/documentation/articles/virtual-machines-linux-coreos-how-to/>如何在 Azure 上使用 CoreOS</a></li><li><a href=https://azure.microsoft.com/zh-tw/documentation/articles/virtual-machines-linux-coreos-fleet-get-started/>開始在 Azure 上的 CoreOS VM 叢集使用 Fleet</a></li></ul><p>這邊我使用的不是Azure的classic vm而是用了resource manager，這部份 可以參考這篇：
<a href=https://azure.microsoft.com/en-us/documentation/articles/resource-group-template-deploy/>Deploy an application with Azure Resource Manager template</a></p><p>要使用arm的話，首先要把模式切到arm:</p><blockquote><p><em>azure config mode arm</em></p></blockquote><p>接下來得建立一個resource group:</p><blockquote><p><em>azure group create -n &ldquo;group_name&rdquo; -l &ldquo;West US&rdquo;</em></p></blockquote><p>-n 後面是這個群組的名字, -l 後面則是它所在區域</p><p>接下來可以利用resource group templates來建立相關的資源, resource group template 除了可以自己寫以外(參考這邊 <a href=https://azure.microsoft.com/en-us/documentation/articles/resource-group-authoring-templates/>Authoring Azure Resource Manager templates</a>), 也可以上<a href=https://azure.microsoft.com/zh-tw/documentation/templates/>Azure 快速入門範本去找現成的</a>, 至於coreos + fleet, 就有一個現成的:<a href=https://azure.microsoft.com/zh-tw/documentation/templates/coreos-with-fleet-multivm/>Deploy a CoreOS cluster hosting Fleet</a>, 它的<a href=https://github.com/Azure/azure-quickstart-templates/tree/master/coreos-with-fleet-multivm>source code在github上也可以找到</a></p><p>基本上應該是改一下azuredeploy.parameters.json再執行下面指令就可以:</p><blockquote><p><em>azure group deployment create GroupName DeploymentName &ndash;template-file azuredeploy.json &ndash;parameters-file azuredeploy.parameters.json</em></p></blockquote><p>而裡面的discovery url部分, 則是要去: <a href="https://discovery.etcd.io/new?size=3">https://discovery.etcd.io/new?size=3</a> 產生一個貼上去</p><p>但我前幾天在試的時候, 似乎它azuredeploy.json的換行有點問題(寫這篇文章時再看它已經是修正了), 以至於我執行起來有點問題, 再加上, 新的coreos stable似乎也改用etcd2取代原本的etcd, 因此我想要用另一個版本的cloud-config(即借用Scaling Docker那段影片裡用的那個cloud-config, 那個即是使用etcd2), 此外他的vm name也全是以coreos開頭的(我想要自己命名)</p><p>因此, 我修改了一個自己的版本, 也放在github上: <a href=https://github.com/julianshen/azure-core-fleet>julianshen/azure-core-fleet</a></p><p>這版本把cloud-config獨立成一個template而非寫死在azuredeploy.json, 並借用上面所述的版本, 並且寫了一隻<em>paramgen.go</em>來產生azuredeploy.parameters.json, discovery url不用自己去產生, 這支程式會自動幫你取得, 用法:</p><ul><li><em>go get github.com/parnurzeal/gorequest</em></li><li><em>go run paramgen.go &ndash;numberOfNodes 3 &ndash;location &ldquo;East US&rdquo; &ndash;newStorageAccountName &ldquo;mystorageaccount&rdquo; &ndash;vmSize &ldquo;Standard_A1&rdquo; &ndash;adminUserName &ldquo;admin&rdquo; &ndash;vmNamePrefix &ldquo;myvm&rdquo; &ndash;sshKeyFile ~/.ssh/azure_rsa.pub</em></li></ul><p>參數如下:</p><ul><li>numberOfNodes 要開的vm數量</li><li>location vm位置(還是得跟你的resource group所在位置一樣)</li><li>newStorageAccountName storage account name</li><li>vmSize VM的大小</li><li>adminUserName 管理者的名稱</li><li>vmNamePrefix vm名字的開頭</li><li>sshKeyFile ssk key的檔案位置(如果沒有,預設是~/.ssh/id_rsa.pub)</li></ul><p>接著跑前面提到那段:</p><blockquote><p><em>azure group deployment create GroupName DeploymentName &ndash;template-file azuredeploy.json &ndash;parameters-file azuredeploy.parameters.json</em></p></blockquote><p>執行結束後就會得到三頭牛, ㄟ,是三台VM(取決於numberOfNodes數目)及相關資源, 而且依據這個範本, 這三台VM跑得都會是coreos, 擁有我們指定的cloud-config, 這cloud-config會在coreos上啟用etcd2, fleet, 和flanneld (如Scaling Docker那段裡面的一樣)</p><p>用ARM的模式的好處是,這三台VM會是在同一個虛擬網路上, 有各自的私有的IP, 當然也有各自的公開IP</p><p>裝好後, 有碰到一個問題, 就是不知道為何, 重啟vm時, 會碰到etcd也跑起來了取代了etcd2, 而etcdctl 2.0.9又跟etcd有相容性問題, 導致fleet出問題, 因此在原本的cloud-config加上了:</p><blockquote><ul><li>name: etcd.service
mask: true</li></ul></blockquote><p>這樣一來etcd就不會去執行了</p><p>再來就要測試剛剛的佈署是不是成功沒問題了</p><p>首先我們需要fleetctl, 如果不希望登入vm就可以使用, 還是可以在本地端安裝, 在mac下可用</p><blockquote><p><em>brew install fleetctl</em></p></blockquote><p>然後要設定兩個環境變數:</p><ul><li><em>export FLEETCTL_TUNNEL=xxx.xxx.xxx.xxx</em></li><li><em>export FLEETCTL_SSH_USERNAME=admin</em> (你設定的admin user名字)</li></ul><p>接下來用:</p><blockquote><p><em>fleetctl list-machines</em> &ndash;full</p></blockquote><p>會得到像這樣的結果:</p><pre>
MACHINE     IP      METADATA
291c678da14841a7bec4c9aa0dfe168c    10.0.0.6    -
8e63696268c54a62a3f21043669997c6    10.0.0.4    -
fbc2675e0aa940e1b11eb6640b62906f    10.0.0.5    -
</pre><p>這表示這三台vm已經都跑起來了, 如果我們要ssh連上第一台可以用這種方式:</p><blockquote><p><em>fleetctl ssh 291c678da14841a7bec4c9aa0dfe168c</em></p></blockquote><p>完全不用知道這台機器的public IP</p><p>有了這三台VM, 接下來要做的事就是要deploy Mongodb的replica set了</p><p>這邊我找到兩個參考:</p><ul><li><a href=https://github.com/19hz/coreos-mongodb-cluster>19hz/coreos-mongodb-cluster</a></li><li><a href=https://github.com/auth0/coreos-mongodb>auth0/coreos-mongodb</a></li></ul><p>第一個其實是參考第二個寫出來的, 這兩個的差異在於第一個使用了data volume container</p><p>Data volume container的優缺點及使用方法可以參考這篇: <a href=https://docs.docker.com/engine/userguide/containers/dockervolumes/>Manage data in containers</a></p><p>本來我想直接採用第一個的, 不過弄了半天, 每次都是在加好admin user後restart mongo時就失敗了, 加上他的方法其實沒辦法保證db container剛好跟data volume container一定在同一台機器(可以參考<a href=https://github.com/19hz/coreos-mongodb-cluster/issues/2>這一個issue</a>), 後來就有點懶得看, 所以改採用第二個方法</p><p>第二個方法還蠻簡單的:</p><ul><li>先ssh到任一台(可以用fleetctl ssh),用etcdctl設定這個變數: <em>etcdctl set /mongo/replica/name myreplica</em></li><li>執行 <em>fleetctl start mongo@{1..3}.service</em> 以及 <em>fleetctl start mongo-replica-config.service</em></li></ul><p>在第一個node跑起來後, 它會建立admin user自動產生它的密碼, 建立replica key, 然後再重啟mongodb, 相關參數像是admin user的密碼就會存在etcd, 會需要花一點時間</p><p>用 <code>fleetctl list-units</code> 就可以看各個的執行結果了, 像這樣</p><pre>
UNIT                MACHINE         ACTIVE      SUB
mongo-replica-config.service    8e636962.../10.0.0.4    inactive    dead
mongo@1.service         8e636962.../10.0.0.4    active      running
mongo@2.service         291c678d.../10.0.0.6    active      running
mongo@3.service         fbc2675e.../10.0.0.5    active      running
</pre><p>mongo-replica-config由於只會跑一次, 所以你會看到他最後的狀態是dead</p><p>這裡建立出來的admin使用者為 <em>siteRootAdmin</em> , 密碼則可以連上任一台, 用etcdctl取得:</p><p><code>etcdctl get /mongo/replica/siteRootAdmin/pwd</code></p><p>有了這個後就可以遠端用mongodb cli或是相關的工具連上這台mongodb了</p><p>心得: fleet在這邊的作用感覺並不是很大, 同樣的東西應該也可以用chef或ansible來佈署, 這邊沒太多異質性的服務需要部屬(也只有一個服務), 而且我常會有連不上的狀況, 不過它算是蠻簡單的, 下次應該來試試kubernetes或是docker swarm</p></div></article><div class=pagination><ul class=inline-list><li><a href=/page/8/ class=btn>Previous</a></li><li><a href=/>1</a></li><li><a href=/page/2/>2</a></li><li><a href=/page/3/>3</a></li><li><a href=/page/4/>4</a></li><li><a href=/page/5/>5</a></li><li><a href=/page/6/>6</a></li><li><a href=/page/7/>7</a></li><li><a href=/page/8/>8</a></li><li><strong class=current-page>9</strong></li><li><a href=/page/10/>10</a></li><li><a href=/page/11/>11</a></li><li><a href=/page/12/>12</a></li><li><a href=/page/13/>13</a></li><li><a href=/page/14/>14</a></li><li><a href=/page/15/>15</a></li><li><a href=/page/16/>16</a></li><li><a href=/page/17/>17</a></li><li><a href=/page/18/>18</a></li><li><a href=/page/19/>19</a></li><li><a href=/page/20/>20</a></li><li><a href=/page/21/>21</a></li><li><a href=/page/22/>22</a></li><li><a href=/page/23/>23</a></li><li><a href=/page/24/>24</a></li><li><a href=/page/25/>25</a></li><li><a href=/page/26/>26</a></li><li><a href=/page/27/>27</a></li><li><a href=/page/28/>28</a></li><li><a href=/page/29/>29</a></li><li><a href=/page/30/>30</a></li><li><a href=/page/31/>31</a></li><li><a href=/page/32/>32</a></li><li><a href=/page/33/>33</a></li><li><a href=/page/34/>34</a></li><li><a href=/page/35/>35</a></li><li><a href=/page/36/>36</a></li><li><a href=/page/37/>37</a></li><li><a href=/page/38/>38</a></li><li><a href=/page/39/>39</a></li><li><a href=/page/40/>40</a></li><li><a href=/page/41/>41</a></li><li><a href=/page/42/>42</a></li><li><a href=/page/43/>43</a></li><li><a href=/page/44/>44</a></li><li><a href=/page/45/>45</a></li><li><a href=/page/46/>46</a></li><li><a href=/page/47/>47</a></li><li><a href=/page/48/>48</a></li><li><a href=/page/49/>49</a></li><li><a href=/page/50/>50</a></li><li><a href=/page/51/>51</a></li><li><a href=/page/52/>52</a></li><li><a href=/page/53/>53</a></li><li><a href=/page/54/>54</a></li><li><a href=/page/55/>55</a></li><li><a href=/page/56/>56</a></li><li><a href=/page/57/>57</a></li><li><a href=/page/58/>58</a></li><li><a href=/page/59/>59</a></li><li><a href=/page/60/>60</a></li><li><a href=/page/61/>61</a></li><li><a href=/page/62/>62</a></li><li><a href=/page/63/>63</a></li><li><a href=/page/64/>64</a></li><li><a href=/page/65/>65</a></li><li><a href=/page/66/>66</a></li><li><a href=/page/67/>67</a></li><li><a href=/page/68/>68</a></li><li><a href=/page/69/>69</a></li><li><a href=/page/70/>70</a></li><li><a href=/page/71/>71</a></li><li><a href=/page/10/ class=btn>Next</a></li></ul></div></div><div class=footer-wrapper><footer role=contentinfo><span>Powered by <a href=https://gohugo.io/ rel=nofollow>Hugo</a> using the <a href=https://github.com/dldx/hpstr-hugo-theme rel=nofollow>HPSTR theme</a>.</span></footer></div><script src=//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js></script><script src=https://kit.fontawesome.com/872a53b461.js crossorigin=anonymous></script><script>window.jQuery||document.write('<script src="\/js\/vendor\/jquery-1.9.1.min.js"><\/script>')</script><script src=/js/scripts.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-79243751-1','auto');ga('send','pageview');}</script><div id=fb-root></div><script async defer crossorigin=anonymous src="https://connect.facebook.net/zh_TW/sdk.js#xfbml=1&version=v7.0&appId=293999444006555&autoLogAppEvents=1" nonce=geZSUIUh></script></body></html>
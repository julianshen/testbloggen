<!doctype html><!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang=en><![endif]--><!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang=en><![endif]--><!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang=en><![endif]--><!--[if gt IE 8]><!--><html class=no-js lang=en><!--<![endif]--><head><meta charset=utf-8><title>淺談Social Feed - 後端架構實作 [Server] &#8211; Le murmure de Julian</title><meta name=description content><meta name=keywords content="concept,social network,software architecture"><meta property="og:title" content="淺談Social Feed - 後端架構實作 [Server]"><meta property="og:description" content="這應該是這系列最後一篇了吧, 雖然回頭看, 可能有些漏寫, 不過, 以後想到再補吧, 如果還沒看過前兩篇, 可以再複習一下: 概念篇,多服務彙整 這篇主要要"><meta property="og:type" content="article"><meta property="og:url" content="http://blog.jln.co/%E6%B7%BA%E8%AB%87Social-Feed-%E5%BE%8C%E7%AB%AF%E6%9E%B6%E6%A7%8B%E5%AF%A6%E4%BD%9C-Server/"><meta property="og:image" content="http://blog.jln.co/images/posts/2016-11-02-%E6%B7%BA%E8%AB%87social-feed---%E5%BE%8C%E7%AB%AF%E6%9E%B6%E6%A7%8B%E5%AF%A6%E4%BD%9C-%5Bserver%5D.md.jpg"><meta property="article:published_time" content="2016-11-02T09:15:35+00:00"><meta property="article:modified_time" content="2016-11-02T09:15:35+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://blog.jln.co/images/posts/2016-11-02-%E6%B7%BA%E8%AB%87social-feed---%E5%BE%8C%E7%AB%AF%E6%9E%B6%E6%A7%8B%E5%AF%A6%E4%BD%9C-%5Bserver%5D.md.jpg"><meta name=twitter:title content="淺談Social Feed - 後端架構實作 [Server]"><meta name=twitter:description content="這應該是這系列最後一篇了吧, 雖然回頭看, 可能有些漏寫, 不過, 以後想到再補吧, 如果還沒看過前兩篇, 可以再複習一下: 概念篇,多服務彙整 這篇主要要"><link rel=canonical href=http://blog.jln.co/%E6%B7%BA%E8%AB%87Social-Feed-%E5%BE%8C%E7%AB%AF%E6%9E%B6%E6%A7%8B%E5%AF%A6%E4%BD%9C-Server/><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/main.css><link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel=stylesheet type=text/css><meta http-equiv=cleartype content="on"><meta name=generator content="Hugo 0.73.0"><script src=/js/vendor/modernizr-2.6.2.custom.min.js></script><script async src=https://unpkg.com/mermaid@8.2.3/dist/mermaid.min.js></script><link rel="shortcut icon" href=/favicon.png></head><body id=post><nav id=dl-menu class=dl-menuwrapper role=navigation style=display:inline-block><button class=dl-trigger>Open Menu</button><ul class=dl-menu><li><a href=/>Home</a></li><li><a href=#>About</a><ul class=dl-submenu><li><img src=/images/avatar.png alt="Julian Shen's photo" class=author-photo><h4>Julian Shen</h4><p>Softward developer</p></li><li><a href=mailto:julianshen22@gmail.com><i class="fa fa-fw fa-envelope"></i>Email</a></li><li><a href=https://linkedin.com/in/julianshen><i class="fa fa-fw fa-linkedin"></i>LinkedIn</a></li><li><a href=https://github.com/julianshen><i class="fa fa-fw fa-github"></i>GitHub</a></li><li><a href=https://instagram.com/julianshen><i class="fa fa-fw fa-instagram"></i>Instagram</a></li></ul></li><li><a href=#>Posts</a><ul class=dl-submenu><li><a href=/post/>All Posts</a></li><li><a href=/tags/>All Tags</a></li></ul></li><li><a href=/></a></li></ul></nav><div id=main role=main><article class=hentry><header class=header-title><div class=header-title-wrap><h1 class=entry-title><a href=/%E6%B7%BA%E8%AB%87Social-Feed-%E5%BE%8C%E7%AB%AF%E6%9E%B6%E6%A7%8B%E5%AF%A6%E4%BD%9C-Server/ rel=bookmark title="淺談Social Feed - 後端架構實作 [Server]">淺談Social Feed - 後端架構實作 [Server]</a></h1><h2><span class="entry-date date published"><time datetime="2016-11-02 09:15:35 +0000 UTC">November 2, 2016</time></span></h2><p class=entry-reading-time><i class="fa fa-clock-o"></i>Reading time ~10 minutes</p></div></header><div class=entry-content><p>這應該是這系列最後一篇了吧, 雖然回頭看, 可能有些漏寫, 不過, 以後想到再補吧, 如果還沒看過前兩篇, 可以再複習一下:
<a href=/%E6%B7%BA%E8%AB%87social-feed-%E6%A6%82%E5%BF%B5%E7%AF%87/>概念篇</a>,<a href=/%E6%B7%BA%E8%AB%87social-feed-%E5%A4%9A%E6%9C%8D%E5%8B%99%E5%BD%99%E6%95%B4%E5%BC%8F%E7%9A%84social-feed-client/>多服務彙整</a></p><p>這篇主要要著眼在如何做Timeline這東西(怎又突然把它叫Timeline了? 好吧, 複習了一下很多文章, 發現這還是比較通用的名詞)</p><p>先借用一下以前跟老闆報告時, 老闆問的</p><pre><code>&quot;做這很難嗎?&quot;
</code></pre><p>這不是啥記恨啦(雖然我還蠻有印象這問題跟我的回答的), 而是開始做這個的時候, 我也覺得應該沒什麼難的, 不過, 實作這個功能本身的確不難,
倒是要讓它可以擴展(scale)這件事, 的確會比較麻煩, 也不止一個方法做, 先從基本來看一下</p><h2 id=什麼構成一個timeline-social-feed->什麼構成一個Timeline (Social feed)</h2><p>Twitter和Facebook主要把這東西分為兩類 - User timeline和Home timeline</p><p>User timeline主要就是單一使用者的近況更新, 也就是所有的內容都是由那個使用者產生, 並以時間排序(不然怎叫Timeline),
這部分倒沒什麼困難的, 因為它就是單一個人的流水帳(從軟體的角度也可以說成他活動的"log&rdquo;)</p><p>Home timeline包含的則不是單一個人的, 而是包含你關注的人所有的動態, 在Twitter就是你follow的人, 而Facebook則是你的朋友加上你關注的人(follow)和粉絲頁,
講"follow"其實蠻貼切的啦, 有點偷窺(光明正大吧?), 又有點跟蹤狂的感覺, 但現今的Home timeline大多(尤其是Facebook)不是用時間排序, 好像也不能真的叫Timeline (ㄠ回來了, 這樣我叫Social feed好像比較貼切 XD)</p><p>假設我follow了user1, user2, user3等三個人, 那我的Home timeline就會變成這樣:</p><p><img src=/images/posts/timline.003.jpeg alt></p><p>Ok, 其實這有點像前一篇講的<a href=/%E6%B7%BA%E8%AB%87social-feed-%E5%A4%9A%E6%9C%8D%E5%8B%99%E5%BD%99%E6%95%B4%E5%BC%8F%E7%9A%84social-feed-client/>多服務彙整</a>那種, 不同的是, 這些feeds是來自於同一個來源, 並不是多個不同的服務, 比較沒資料異質性問題</p><h2 id=1-9-90-理論->1 9 90 理論</h2><p>在切入實作面之前, 先提一下這個理論, 這邊有Mr. Jamine對這個的解釋: <a href=http://mrjamie.cc/2013/08/08/1-9-90-rule/>&ldquo;網路內容的 1/9/90 定律&rdquo;</a>
(他用"定律&rdquo;, 但定律是比較恆常的, 但這比例並不是那麼的絕對, 所以我比較覺得用理論或假設比較適合)</p><p>這理論說的是, 大約有90%(甚或以上)的人是屬於讀者, 9%的人會參與進一步互動(比如說按讚或回文), 只有1%的創作者(你可以看一下你自己是屬於哪類的人),
根據我的經驗, 讀者可能會多於90%, 創作者甚至可能少於1%</p><p>那對於開發者來說, 知道這些有什麼用? 我個人是覺得一個開發者或是架構設計者, 必須要清楚暸解所做的東西所會產生的行為才能產出一個好的架構, 以這個來說,
如果要設計一個高度可擴展的架構的話, 我們可知道, 絕大部分的request其實都是讀取(read), 高併發(highly concurrent)的寫入機會並不大(反而比較容易發生在like, comment)</p><h2 id=比較直覺的實作方式->比較直覺的實作方式</h2><p>好, 難免的, 我一開始也是選用這種方式 - 都交給資料庫(database), 這邊的資料庫, 不管SQL或No-SQL, 差不多原理啦, 雖然說針對Feed這種time squences看起來像比較適合No SQL, 但Facebook不也是用My SQL(雖然用的方式比較是key-value的方式)</p><p>依照前面的說法, 我們可以簡單的假設有兩種資料 - 使用者(User)和內容(Feed)</p><ol><li>使用者可以跟隨(Follow)其他使用者(這邊引用Twitter的設定), 因此每個使用者會有n個"follower&rdquo;</li><li>使用者可以發文(Feed/Post), 每則發文都有(只有)一個作者(author)</li><li>每個使用者的Homeline是由他跟隨的所有人的發文所組成</li><li>每次client來要求homeline最多給m則(比如說25則)</li></ol><p>按照這樣的說法, 我們可以想像Query或許長得像這樣(No SQL版本自行想像):</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-SQL data-lang=SQL><span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> FEED <span style=color:#66d9ef>WHERE</span> AUTHOR <span style=color:#66d9ef>IN</span> (<span style=color:#66d9ef>SELECT</span> FOLLOWERS <span style=color:#66d9ef>FROM</span> <span style=color:#66d9ef>USER</span> <span style=color:#66d9ef>WHERE</span> ID<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;myid&#39;</span>) <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> TIME LIMITS m
</code></pre></div><p>這邊暫時先省略掉query出來你還要再query出user大頭照跟人名的部分, 但加上這部分每次至少要有兩次queries</p><p>這樣不就搞定了? 有什麼問題? 有, 後面就會撐不住了! (切身之痛), 先來看看什麼問題</p><h3 id=查詢效率->查詢效率</h3><p>從上面的query來說, 它還包含了個sub query去取出所有的followers, 所以這整串在資料庫裡可能的做法是, 把所有相關使用者的feed取出,
在記憶體中排序, 取前m個, 前面有提到, Feed就像流水帳, 全部的人加起來可能不少, 這聽起來就像是耗時耗CPU的查詢</p><p>因此在兩個狀況下就慘了:</p><ol><li>讀取高併發時</li><li>使用者follow了"一大堆"人!!!</li></ol><p>關於第一點, 這很容易發生呀! 90%的人一天到晚窺探&mldr;ㄟ &mldr;關心&mldr;人家在幹嘛, 當一堆這些queries湧入, 資料庫會非常忙碌的, 因為沒有不同的兩個人會follow同樣的人, 根本無法cache</p><p>第二點其實更慘了, follow個幾個人還好, 幾十個人還搞得定, 偏偏這個社群網路時代的, 幾百人是標配, 上千人的也不少, 如果有上萬, 可能更跑不動了(Facebook限制你只能交5000個朋友, Twitter超過5000也是選擇性的讓你少量follow, 所以上萬目前應該還比較少見)</p><h3 id=materialized-view->Materialized View</h3><p>有些資料庫, 像是<a href=http://www.fromdual.com/mysql-materialized-views>MySQL</a>, <a href=postgresql.org/docs/9.3/static/sql-creatematerializedview.html>Postgresql</a>, <a href=http://www.datastax.com/dev/blog/new-in-cassandra-3-0-materialized-views>Cassandra (3.0+)</a>都有支援Materialized view, materialized view就像是一個query的snapshot, join的部分是發生在create或是refresh時, 因此用來解決讀取高併發可能是可行的, 因為讀取時只有單純的query, 直到有更新時再呼叫refresh</p><p>但對於更新比較頻繁, 比較熱門的social network service, 資料庫的負擔還是不算小</p><h3 id=sharding->Sharding</h3><p>如果以時間為基準來做sharding, 或許可以解決這兩個問題, 因為不是所有的人不時都在更新狀態, 所以在含有最新的shard裡面包含的可能只有少數人的feed, 這減少了遍訪所有人的feed的工, 而且不用排序所有的feed</p><p>但還是有幾個問題:</p><ol><li>無法join, 如果根據feed的時間去做sharding, feed跟user就不見得在同一資料庫, 這樣就無法join了</li><li>邊界問題, 有可能你需要的資料剛好就在時間間界的附近, 導致一開始query不到足夠的資料</li></ol><p>其實上面問題寫程式解決都不是問題啦, 這邊想說的只是, 沒辦法以一兩個簡單的queries就搞定了</p><h2 id=大家都怎麼做->大家都怎麼做</h2><p>這邊講的"大家"就那些大咖囉, Facebook, Twitter, Pinterest, Tumblr &mldr;等等, 關於這個問題, 其實Yahoo曾經出過一篇論文:</p><p><a href=http://jeffterrace.com/docs/feeding-frenzy-sigmod10-web.pdf>&ldquo;Feeding Frenzy: Selectively Materializing Users’ Event
Feeds&rdquo;</a></p><p>如果沒耐心看完論文(我也沒耐心), 這邊先簡單提一下兩種模式:</p><ol><li>Push model</li><li>Pull model</li></ol><p><img src=/images/posts/timline.005.jpeg alt></p><p>Push model又被稱為Megafeed(<a href=https://www.infoq.com/presentations/Facebook-News-Feed>根據某場Facebook的分享</a>),
而Pull model則是Facebook使用的Multifeed, 其實不管哪種模式, 大多不是直接存取資料庫增加資料庫的負擔, 而是大量的應用快取(cache), 像是Memcached, Redis等等</p><p>簡單的來說, Push model在整合feed的時間發生在寫入, 而Pull model則是發生在讀取</p><h3 id=push-model-megafeed->Push model (Megafeed)</h3><p>這是Twitter所採用的方式, 也是我以前採用過的做法, 我自己則是把它稱為Inbox model, 比較詳細的內容推薦可以參考Twiter的:</p><p><a href=https://www.infoq.com/presentations/Twitter-Timeline-Scalability>&ldquo;Timelines at Scale&rdquo;</a></p><p>先來看看他們這張架構圖</p><p><img src=/images/posts/twitter_mega_feed.png alt></p><p>Home timeline的部分主要是中間的那個流程, 這做法比較像是E-mail一樣(所以我才稱它為inbox), 當使用者發表了一則新的動態後,
系統會根據有訂閱這則動態有那些人(也就是follow這個使用者的人), 然後把這則動態複製到各個訂閱者的Home timeline (Inbox)上</p><p>這方法的優點是, 對於讀取相當之快, 因為Home timeline已經在寫入期間就準備好了, 所以當使用者要讀取時, 不需要複雜的join就能取得, 在做pagination也相當簡單, 因為本來就是依時序排下去的</p><p>但缺點是, 很顯而易見的, 非常耗費空間, 因為每個timeline都要複製一份, 假設你被上千人follow, 就要上千份, 因此Twitter只有存ID和flag, 詳細的內容跟Meta data, 是後來才從cache去合併來的, 另外Twitter也只存了最近的八百則, 所以你不可能得無窮無盡的往前滑</p><p>另一點就是耗時, 這種寫入通常是非同步的, 使用者發布動態後, 他只知道他動態發布成功了, 但系統還需要在背後寫到各個Inbox中, 因此他不會知道別人其實可能還看不到的, 對於一個follower數量不多的不是問題,
但如果像是Lady gaga那種大人物, 有幾百萬粉絲, 那就是大問題了! 寫入幾百萬的timeline即使只寫入memcached也是相當耗時的事,
而且這會產生時間錯亂的問題, follower比較少得很快就做完了, 所以很容易看到比較熱門的人物的貼文比較晚出現</p><p>Twitter是把follower多的人另案處理, 也就是讀取時段再合併(那就是類似下面要講的multifeed了), 這樣可以省下一些空間跟時間, 另一種可行的做法(我們之前的做法),
就是不寫到所有人的timeline, 而是只cache最近有上線的人的timeline, 這樣就算Lady gaga有幾百萬粉絲, 實際上最近才有上線的可能才幾十萬或更少,
處理這部分就好了, 如果cache裡面並沒有現在上線這個人的timeline, 就在從資料庫讀取合成就好</p><p>不過總歸來說, 這方法讀取快, 但寫入慢, 耗費空間, 較適合讀比寫多上許多的應用</p><p>此外其實也有不同的變形, 像是Pinterest:</p><p><a href=https://engineering.pinterest.com/blog/building-smarter-home-feed>Building a smarter home feed</a></p><h3 id=pull-model-multifeed->Pull model (Multifeed)</h3><p>Facebook採用了一個完全不同的方式, 叫做Multifeed, 這方式從2009開始在Infoq就一直被提到:</p><ol><li><a href=https://www.infoq.com/presentations/Facebook-Software-Stack>Facebook: Science and the Social Graph</a> 2009, by Aditya Agarwal</li><li><a href=https://www.infoq.com/presentations/Scale-at-Facebook>Scale at Facebook</a> 2010, by Aditya Agarwal</li><li><a href=https://www.infoq.com/presentations/Facebook-News-Feed>Facebook News Feed: Social Data at Scale</a> 2012, by Serkan Piantino (Aditya Agarwal這時候應該跑到Dropbox去了)</li></ol><p>這跟Push model有什麼不同? 其實說起來跟前面一開始用DB的方式比較像, 就是在讀取時, 才取得所跟隨的人的feed, 合併並排序,
但這樣不是讀取很沒效率嗎?先來看看圖:</p><p><img src=/images/posts/timline.004.jpeg alt></p><ol><li>在寫入時, feed資料只會寫入"一個"leaf server, 應該是根據user去分流的</li><li>leaf server主要是memcached, 所以都是in memory的</li><li>在memory裡面不可能保存所有動態, 只會保存最近一段時間的 (所以不可能包含所有人所有的動態, 在做整合時就輕鬆多了)</li><li>前端跟Aggregator query後, Aggregator會去跟"所有"的leaf server問所有相關的人的feed再回來整合</li></ol><p>因為資料存儲跟處理都在memory, 所以可以很快, 但還是要考慮到網路的部分, 因此leaf server跨區的話效率就不會高了, 自然空間需求會比Pull model來得少, 但home timeline的讀取時間就較長了(因為是read time aggregation的關係),也不會有名人問題, 不會因為follower多, 複製耗時耗空間
另一個優點是, 排序的方式控制在Aggregator, 因此很容易立刻更動規則, 不像pull model, 當home timeline組好後要去變動它就較麻煩</p><h3 id=混搭風->混搭風</h3><p>當然沒有絕對的好壞, 兩種模式各有優缺, 所以也有人採用的是混合模式, 根據使用者使用頻率來決定, 這就跟穿衣服一樣, 每個人怎搭衣服都是不一樣的, 端看你要怎混搭</p><h2 id=rest-api的問題->REST API的問題</h2><p>在前面一篇<a href=/%E6%B7%BA%E8%AB%87social-feed-%E5%A4%9A%E6%9C%8D%E5%8B%99%E5%BD%99%E6%95%B4%E5%BC%8F%E7%9A%84social-feed-client/>多服務彙整</a>裡有提到REST API都是輪詢(polling)的模式, 不管資料有沒更新,
Client都是會常常來server查詢資料, 這對server可能會是夢靨, 因為只有1%在努力創作, 所以搞不好有很大量的查詢都是浪費的, 而這些查詢通常是造成系統多餘負擔的元兇</p><p>關於這問題, 我有兩個想法, 不過都還沒實際去實證過</p><ol><li>增加HEAD的API, 大部分REST API是以GET直接抓取資料, 所以針對個別資源(Resource), 應可實作HEAD, 讓Client在實際去查詢資料前先確訂一下資源的更新時間, 資源的更新時間在資料更新時就可以放在cache內了, 相對的可以省傳輸的數據量跟處理時間</li><li>利用PUSH, 現在大部分的應用都在手機上, 也大多有實作PUSH, 當有資料更新且App在前景時, 利用PUSH通知有資料更新, Client收到後才會真的去抓取, 不過這比較起來感覺相對負擔較重</li></ol><p>另外這篇也是值得去參考(只是這個還要帶入XMPP):</p><p><a href=http://cdn.oreillystatic.com/en/assets/1/event/12/Beyond%20REST_%20Building%20Data%20Services%20with%20XMPP%20PubSub%20Presentation.pdf>Beyond REST?Building data services with XMPP PubSub</a></p><footer class=entry-meta><span class=entry-tags><a href=/tags/#concept title="Pages tagged concept" class=tag><span class=term>concept</span></a><a href=/tags/#social-network title="Pages tagged social-network" class=tag><span class=term>social-network</span></a><a href=/tags/#software-architecture title="Pages tagged software-architecture" class=tag><span class=term>software-architecture</span></a></span><div class=social-share><ul class="socialcount socialcount-small inline-list"><li class=facebook><a href="https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2fblog.jln.co%2f%25E6%25B7%25BA%25E8%25AB%2587Social-Feed-%25E5%25BE%258C%25E7%25AB%25AF%25E6%259E%25B6%25E6%25A7%258B%25E5%25AF%25A6%25E4%25BD%259C-Server%2f" target=_blank title="Share on Facebook"><span class=count><i class="fa fa-facebook-square"></i>Like</span></a></li><li class=twitter><a href="https://twitter.com/intent/tweet?text=http%3a%2f%2fblog.jln.co%2f%25E6%25B7%25BA%25E8%25AB%2587Social-Feed-%25E5%25BE%258C%25E7%25AB%25AF%25E6%259E%25B6%25E6%25A7%258B%25E5%25AF%25A6%25E4%25BD%259C-Server%2f" target=_blank title="Share on Twitter"><span class=count><i class="fa fa-twitter-square"></i>Tweet</span></a></li><li class=line><a href="https://social-plugins.line.me/lineit/share?url=http%3a%2f%2fblog.jln.co%2f%25E6%25B7%25BA%25E8%25AB%2587Social-Feed-%25E5%25BE%258C%25E7%25AB%25AF%25E6%259E%25B6%25E6%25A7%258B%25E5%25AF%25A6%25E4%25BD%259C-Server%2f" target=_blank title="Share on LINE"><span class=count><i class="fab fa-line"></i>LINE</span></a></li></ul></div></footer></div><section id=disqus_thread><div class=fb-comments data-href=http://blog.jln.co/%E6%B7%BA%E8%AB%87Social-Feed-%E5%BE%8C%E7%AB%AF%E6%9E%B6%E6%A7%8B%E5%AF%A6%E4%BD%9C-Server/ data-numposts=5 data-width></div></section></article></div><div class=footer-wrapper><footer role=contentinfo><span>Powered by <a href=https://gohugo.io/ rel=nofollow>Hugo</a> using the <a href=https://github.com/dldx/hpstr-hugo-theme rel=nofollow>HPSTR theme</a>.</span></footer></div><script src=//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js></script><script src=https://kit.fontawesome.com/872a53b461.js crossorigin=anonymous></script><script>window.jQuery||document.write('<script src="\/js\/vendor\/jquery-1.9.1.min.js"><\/script>')</script><script src=/js/scripts.min.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-79243751-1','auto');ga('send','pageview');}</script><div id=fb-root></div><script async defer crossorigin=anonymous src="https://connect.facebook.net/zh_TW/sdk.js#xfbml=1&version=v7.0&appId=293999444006555&autoLogAppEvents=1" nonce=geZSUIUh></script></body></html>